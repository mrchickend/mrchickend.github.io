{"posts":[{"title":"平面向量与三角形的四心","content":"初学平面向量做题时，总会遇到这样的条件： 在ΔABC\\Delta ABCΔABC内，有一点OOO满足OA→+OB→+OC→=0⃗\\overrightarrow{OA}+\\overrightarrow{OB}+\\overrightarrow{OC}=\\vec{0}OA+OB+OC=0 ............. 当然我们都知道，这个条件便说明了OOO点是δABC\\delta ABCδABC的重心 由此我便产生了一个疑惑：能否将这种类似的结论推广到其他三心呢？（暂不讨论旁心） 首先介绍一下著名的“奔驰定理”： 如图，对于任意ΔABC\\Delta ABCΔABC内部一点OOO，都有SΔBOC⋅OA→+SΔAOC⋅OB→+SΔAOB⋅OC→=0⃗S_{\\Delta BOC} \\cdot \\overrightarrow{OA} + S_{\\Delta AOC} \\cdot \\overrightarrow{OB} + S_{\\Delta AOB} \\cdot \\overrightarrow{OC} = \\vec{0}SΔBOC​⋅OA+SΔAOC​⋅OB+SΔAOB​⋅OC=0 该定理还可以推广到OOO点在三角形外部的情况，留给读者自行推导 三角形的四心可以看成是奔驰定理的特殊情况 当OOO为重心时 因为SΔAOB=SΔAOC=SΔBOCS_{\\Delta AOB}=S_{\\Delta AOC}=S_{\\Delta BOC}SΔAOB​=SΔAOC​=SΔBOC​ 所以 OA→+OB→+OC→=0→\\overrightarrow{OA}+\\overrightarrow{OB}+\\overrightarrow{OC}=\\overrightarrow{0} OA+OB+OC=0 当OOO为外心时： 由于∣OA→∣=∣OB→∣=∣OC→∣|\\overrightarrow{OA}|=|\\overrightarrow{OB}|=|\\overrightarrow{OC}|∣OA∣=∣OB∣=∣OC∣ 那么&lt;OA→,OB→&gt;=2∠ACB,&lt;OA→,OC→&gt;=2∠ABC,&lt;OB→,OC→&gt;=2∠BAC&lt;\\overrightarrow{OA},\\overrightarrow{OB}&gt;=2\\angle ACB , &lt;\\overrightarrow{OA},\\overrightarrow{OC}&gt;=2\\angle ABC , &lt;\\overrightarrow{OB},\\overrightarrow{OC}&gt;=2\\angle BAC&lt;OA,OB&gt;=2∠ACB,&lt;OA,OC&gt;=2∠ABC,&lt;OB,OC&gt;=2∠BAC 又因为有面积公式SΔ=12absin⁡CS_{\\Delta}=\\frac{1}{2}ab\\sin CSΔ​=21​absinC 则可以推出 sin⁡2A⋅OA→+sin⁡2B⋅OB→+sin⁡2C⋅OC→=0→\\sin 2A \\cdot \\overrightarrow{OA} + \\sin 2B \\cdot \\overrightarrow{OB} + \\sin 2C \\cdot \\overrightarrow{OC}=\\overrightarrow{0} sin2A⋅OA+sin2B⋅OB+sin2C⋅OC=0 当OOO为内心时： 因为OD=OE=OFOD=OE=OFOD=OE=OF且OD⊥AB,OE⊥AC,OF⊥BCOD \\bot AB , OE \\bot AC , OF \\bot BCOD⊥AB,OE⊥AC,OF⊥BC 所以BC⋅OA→+AC⋅OB→+AB⋅OC→=0→BC \\cdot \\overrightarrow{OA} + AC \\cdot \\overrightarrow{OB} + AB \\cdot \\overrightarrow{OC} = \\overrightarrow{0}BC⋅OA+AC⋅OB+AB⋅OC=0 由正弦定理，可以将式子进一步变形： sin⁡A⋅OA→+sin⁡B⋅OB→+sin⁡C⋅OC→=0→\\sin A \\cdot \\overrightarrow{OA} + \\sin B \\cdot \\overrightarrow{OB} + \\sin C \\cdot \\overrightarrow{OC} = \\overrightarrow{0} sinA⋅OA+sinB⋅OB+sinC⋅OC=0 当OOO为垂心时： 观察到∣OA→∣cos⁡∠AOB=∣OC→∣cos⁡∠BOC=−OE|\\overrightarrow{OA}|\\cos \\angle AOB = |\\overrightarrow{OC}|\\cos \\angle BOC = -OE∣OA∣cos∠AOB=∣OC∣cos∠BOC=−OE 所以 OA→⋅OB→=OA→⋅OC→=OB→⋅OC→\\overrightarrow{OA}\\cdot\\overrightarrow{OB}=\\overrightarrow{OA}\\cdot\\overrightarrow{OC}=\\overrightarrow{OB}\\cdot\\overrightarrow{OC} OA⋅OB=OA⋅OC=OB⋅OC 当ΔABC\\Delta ABCΔABC不是直角三角形时 注意到SΔAOBSΔAOC=BFCF=tan⁡Ctan⁡B\\frac{S_{\\Delta AOB}}{S_{\\Delta AOC}}=\\frac{BF}{CF}=\\frac{\\tan C}{\\tan B}SΔAOC​SΔAOB​​=CFBF​=tanBtanC​，则SΔOBC:SΔOAC:SΔOAB=tan⁡A:tan⁡B:tan⁡CS_{\\Delta OBC} : S_{\\Delta OAC} : S_{\\Delta OAB} = \\tan A : \\tan B : \\tan CSΔOBC​:SΔOAC​:SΔOAB​=tanA:tanB:tanC 运用奔驰定理可获得： tan⁡A⋅OA→+tan⁡B⋅OB→+tan⁡C⋅OC→=0→(∠A,∠B,∠C≠π2)\\tan A \\cdot \\overrightarrow{OA} + \\tan B \\cdot \\overrightarrow{OB} + \\tan C \\cdot \\overrightarrow{OC} = \\overrightarrow{0} (\\angle A , \\angle B , \\angle C \\neq \\frac{\\pi}{2}) tanA⋅OA+tanB⋅OB+tanC⋅OC=0(∠A,∠B,∠C​=2π​) ","link":"https://mrchickend.github.io/post/ping-mian-xiang-liang-yu-san-jiao-xing-de-si-xin/"},{"title":"寒假集训总结（优先队列、树状数组）","content":"寒假的东西五一才写完 刚考完期末，隔两天就来上竞赛，真有学校的 简单记录一下学的东西 优先队列 优先队列就是拥有First In Largest Out行为特征的一种队列，优先级最高的总是在队首 比如一个数列：5 7 1 3 9，入队后就是：1 3 5 7 9 STL里有使用二叉堆的优先队列的实现，使用时需包含头文件&lt;priority_queue&gt; 定义方式： priority_queue&lt;Type,Container,Functional&gt; 如果使用priority_queue&lt;Type&gt;定义，则默认是priority_queue&lt;Type,vector&lt;Type&gt;,less&lt;Type&gt; &gt; 同时注意&gt;与&gt;或者&lt;与&lt;之前需要打空格隔开，否则会引起歧义 priority_queue的常用的成员函数如下： empty() 如果队列为空返回true，反之返回false size() 返回队列中元素个数 top() 返回队首元素的引用形式 pop() 弹出队首元素 push(T&amp;&amp; obj) 将元素obj压入队列 详细的可以看 举个实例 [NOIP2004 提高组] 合并果子 洛谷P1090 乍一看这道题以为是石子合并，但石子是有序的一圈，而这道题中的果子是无序的 因此可以直接使用一个优先队列维护最小的果子的堆的质量，每次取队首两堆果子合并后再压入队列 #include&lt;bits/stdc++.h&gt; using namespace std; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; c; int n,fruit; int min1,min2,sum; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;fruit); c.push(fruit); } while(c.size()&gt;=2) { min1=c.top(); c.pop(); min2=c.top(); c.pop(); sum+=(min1+min2); c.push(min1+min2); min1=min2=0; } printf(&quot;%d&quot;,sum); return 0; } 双倍经验：[福建省夏令营] 瑞瑞的木板 洛谷P1334 另外优先队列还可以实现堆排序，时间复杂度为O(nlog⁡n)O(n\\log n)O(nlogn)，但慢于快速排序 树状数组 树状数组就是树形逻辑结构的数组，维护的复杂度是O(log⁡n)O(\\log n)O(logn)，查询和修改的复杂度为O(1)O(1)O(1) 功能有： 单点修改 区间和 区间更新 ......... 单点修改 配合一张经典的图来看： 我们可以观察到：（A[]为原数组，C[]为树状数组） C[1]=C[(1)2]=A[(1)2]C[1]=C[(1)_{2}]=A[(1)_{2}] C[1]=C[(1)2​]=A[(1)2​] C[2]=C[(10)2]=C[(1)2]+A[(10)2]C[2]=C[(10)_{2}]=C[(1)_{2}]+A[(10)_{2}] C[2]=C[(10)2​]=C[(1)2​]+A[(10)2​] C[3]=C[(11)2]=A[3]C[3]=C[(11)_{2}]=A[3] C[3]=C[(11)2​]=A[3] C[4]=C[(101)2]=C[(10)2]+C[(11)2]+A[4]C[4]=C[(101)_{2}]=C[(10)_{2}]+C[(11)_{2}]+A[4] C[4]=C[(101)2​]=C[(10)2​]+C[(11)2​]+A[4] ............ ...... 从二进制的角度看，C[2]=C[(10)2]C[2]=C[(10)_{2}]C[2]=C[(10)2​]，C[4]=C[(101)2]=C[(10)2]+C[(11)2]+A[(101)2]C[4]=C[(101)_{2}]=C[(10)_{2}]+C[(11)_{2}]+A[(101)_{2}]C[4]=C[(101)2​]=C[(10)2​]+C[(11)2​]+A[(101)2​] 如果修改了A[2]A[2]A[2]的值，那么边要依次修改C[2]C[2]C[2]和C[4]C[4]C[4]的值 注意到(101)2=(10)2+(10)2(101)_{2}=(10)_{2}+(10)_{2}(101)2​=(10)2​+(10)2​ 规律可能不太明显，只要多写出几个来，便不难发现，上式可以写成：(101)2=(10)2+(10)2的最低含1位(101)_{2}=(10)_{2}+(10)_{2}的最低含1位(101)2​=(10)2​+(10)2​的最低含1位 要求出这个最低含1位，可以利用位运算，这里引入一个函数lowbit()： int lowbit(int x) { return x&amp;(-x); } 代码十分简洁。下面给出正确性证明： 由于数据在计算机中是以补码形式储存的，若一个自然数的补码表示的末位为0，那么求它的相反数补码的过程中，必然从末位一直向前进位，直到原数的最低位1为止（因为该位取反后为0）；若末位为1，那么相反数的补码末位也为1 例如7的补码表示为00000111，-7的补码表示为11111001，7和-7做与运算后便得到00000001，即lowbit(7)=1lowbit(7)=1lowbit(7)=1 根据上述内容，如果我给A[i]A[i]A[i]加上了一个数xxx，便要执行以下操作： for(i;i&lt;=N;i+=lowbit(i)) C[i]+=x; 以维护整个树状数组，因为修改A[i]A[i]A[i]会影响到C[i+lowbit(i)]、C[i+lowbit(i)+lowbit(i+lowbit(i))]、......C[i+lowbit(i)]、C[i+lowbit(i)+lowbit(i+lowbit(i))]、......C[i+lowbit(i)]、C[i+lowbit(i)+lowbit(i+lowbit(i))]、......的值 区间和 要求出A数组在区间[x,y][x,y][x,y]上的区间和，可以利用前缀和的思想实现： sum(x,y)=sum(1,y)−sum(1,x−1)sum(x,y)=sum(1,y)-sum(1,x-1) sum(x,y)=sum(1,y)−sum(1,x−1) 求出一个前缀和，也可以通过lowbit()实现 举个例子，要求sum(1,3)=A[1]+A[2]+A[3]的值，即求C[2]+C[3]=C[3-lowbit(3)]+C[3]的值，因为C[2-lowbit(2)]=C[0]不再有意义，于是求到这里就可以了 给出代码 int sum(int k) { int ans=0; while(k!=0) { ans+=C[k]; k-=lowbit(k); } return ans; } 区间修改 区间修改将用到差分的思想，在此就不再赘述，留给读者自行思考 洛谷上有两道树状数组的模板题，如果能够独立写出，树状数组就没有多大问题了： 单点修改与区间和 题解： #include&lt;bits/stdc++.h&gt; using namespace std; int A,C[500005]; int N,M,opt,l,r; int lowbit(int x) { return x &amp; (-x); } void update(int k,int x) { while(k&lt;=N) { C[k]+=x; k+=lowbit(k); } return; } int sum(int k) { int ans=0; while(k!=0) { ans+=C[k]; k-=lowbit(k); } return ans; } int main() { scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;++i) { scanf(&quot;%d&quot;,&amp;A); update(i,A); } for(int i=1;i&lt;=M;++i) { scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;l,&amp;r); if(opt==1) { update(l,r); } if(opt==2) { printf(&quot;%d\\n&quot;,sum(r)-sum(l-1)); } } return 0; } 区间修改与单点查询 题解： #include&lt;bits/stdc++.h&gt; using namespace std; int A,C[500005]; int N,M,opt,a,b,c; int p; inline int read() { int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')w=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w; } int lowbit(int x) { return x &amp; (-x); } void update(int k,int x) { while(k&lt;=N) { C[k]+=x; k+=lowbit(k); } return; } long long sum(int k) { long long ans=0; while(k!=0) { ans+=C[k]; k-=lowbit(k); } return ans; } int main() { N=read(); M=read(); for(int i=1;i&lt;=N;++i) { A=read(); update(i,A-p); p=A; } for(int i=1;i&lt;=M;++i) { opt=read(); if(opt==1) { a=read(); b=read(); c=read(); update(a,c); update(b+1,-c); } if(opt==2) { a=read(); printf(&quot;%lld\\n&quot;,sum(a)); } } return 0; } ","link":"https://mrchickend.github.io/post/han-jia-ji-xun-zong-jie-you-xian-dui-lie-xian-duan-shu-shu-zhuang-shu-zu/"},{"title":"CSP-S 2020 游记","content":"记流水账警告 第一轮 day-6 to day-3 双节假期被拿了四天集训，蒟蒻震怒。 刚进高中，第一次来机房，周围都是不认识的神犇，蒟蒻哭泣。 高二的教练外出旅游还没回来（，闷着头刷了四天的题。 中午回寝室，整栋楼就只有我一个人。 day-2 魔鬼生活结束惹！拥抱文化课！ day-1 树、图、组合数学、概率都还没学，确信自己过不了初赛的情况下安然入土。 day1(??day0??) 前面的单选题怒错16分，读程序全靠蒙。 早上的包子很好吃，明年再买。 day8 知道成绩了，79分，先前没敢估分，大概猜的自己只有4、50，意料之外，激动。 (去年普及组50多的情景还历历在目) 今年这分数线就nm离谱？？？？70.5谁顶的住啊 第二轮 day-6 to day-1 复赛前一周了，仍然是很多没学。 教练决定的是停晚自习，显然时间是远远不够的，便自己旷掉一些白天的课到机房搓代码。辗转各个机房，哪里没人用就去哪里(坐一会就被赶走的痛)。 一周冲完最短路、线性dp和背包。从机房回去同学都说我脸上写着问号？ day1 上午还在学区间dp的djx是鉴 在外面排队，一群蓝白校服orz tg的题目，pj的解压密码，我直呼内行 T1 懂的都懂，考场上就已经想到出题人怎么被骂了 硬着头皮交了份只过了第一个样例的代码，思路就是while一天一天模拟 坐我左前方的老哥调了三个多小时，希望人没事 T2 读不懂题，我是屑qaq （于是cout&lt;&lt;样例输出 T3 模拟过了两个小样例，大样例非RE即TLE T4 时间不太够没仔细想，以为是道dp (cout&lt;&lt;样例输出) 出考场的一刻甚至想AFO 成七巨佬：T1没马！！！！ 电子科大校园挺好看的，后悔来的时候没拍照，出考场天已经黑了 day2 洛谷民间数据自测爆零:(，再**的见 快乐源于看其他人写儒略历 day? 出成绩了，果然爆零了 明年再加油吧 总结： 侥幸过了初赛，但还是在复赛暴露了自己蒟蒻的身份 他山之石，可以攻玉，来年继续加油！(明年国庆大概可以混进城外集训吧) ","link":"https://mrchickend.github.io/post/csp-s-2020-you-ji/"},{"title":"平面直角坐标系中的旋转坐标变换公式","content":"本文写于初中，仅供参考。不成熟的地方请包涵 如图，P(x0,y0)P(x_{0},y_{0})P(x0​,y0​)为坐标平面内一点，绕坐标原点O将点P逆时针旋转β\\betaβ度到P′(x,y)P&#x27;(x,y)P′(x,y) 先给出结论： x=x0cos⁡β−y0sin⁡βx=x_{0}\\cos\\beta-y_{0}\\sin\\betax=x0​cosβ−y0​sinβ y=x0sin⁡β+y0cos⁡βy=x_{0}\\sin\\beta+y_{0}\\cos\\betay=x0​sinβ+y0​cosβ 以下是证明过程： 设∠POA=α\\angle POA=\\alpha∠POA=α，则有 OP′=OP=x0cos⁡α=y0sin⁡αOP&#x27;=OP=\\frac{x_{0}}{\\cos\\alpha}=\\frac{y_{0}}{\\sin\\alpha} OP′=OP=cosαx0​​=sinαy0​​ 于是可以表示P′P&#x27;P′的坐标 x=OP′cos⁡(α+β)=x0cos⁡(α+β)cosαx=OP&#x27;\\cos(\\alpha +\\beta)=\\frac{x_{0}\\cos(\\alpha +\\beta)}{cos\\alpha} x=OP′cos(α+β)=cosαx0​cos(α+β)​ y=OP′sin⁡(α+β)=y0sin⁡(α+β)sin⁡αy=OP&#x27;\\sin(\\alpha +\\beta)=\\frac{y_{0}\\sin(\\alpha +\\beta)}{\\sin\\alpha} y=OP′sin(α+β)=sinαy0​sin(α+β)​ 应用正弦和余弦的和角公式 x=x0(cos⁡αcos⁡β−sin⁡αsin⁡β)cos⁡α=x0cos⁡β−x0tan⁡αsin⁡β=x0cos⁡β−y0sin⁡βx=\\frac{x_{0}(\\cos\\alpha \\cos\\beta-\\sin\\alpha \\sin\\beta)}{\\cos\\alpha}=x_{0}\\cos\\beta-x_{0}\\tan\\alpha\\sin\\beta=x_{0}\\cos\\beta-y_{0}\\sin\\betax=cosαx0​(cosαcosβ−sinαsinβ)​=x0​cosβ−x0​tanαsinβ=x0​cosβ−y0​sinβ y=y0(sin⁡αcos⁡β+cos⁡αsin⁡β)sin⁡α=y0cos⁡β+y0cot⁡αsin⁡β=x0sin⁡β+y0cos⁡βy=\\frac{y_{0}(\\sin\\alpha \\cos\\beta+\\cos\\alpha \\sin\\beta)}{\\sin\\alpha}=y_{0}\\cos\\beta+y_{0}\\cot\\alpha\\sin\\beta=x_{0}\\sin\\beta+y_{0}\\cos\\betay=sinαy0​(sinαcosβ+cosαsinβ)​=y0​cosβ+y0​cotαsinβ=x0​sinβ+y0​cosβ 由此便得到了最开始给出的结论 这个公式仅限于绕坐标原点 逆时针 旋转 显然，如果要推广到绕任意一点(m,n)(m,n)(m,n)旋转，只需要做一点点修改（由平移易证）： x=(x0−m)cos⁡β−(y0−n)sin⁡β+mx=(x_{0}-m)\\cos\\beta-(y_{0}-n)\\sin\\beta+mx=(x0​−m)cosβ−(y0​−n)sinβ+m y=(x0−m)sin⁡β+(y0−n)cos⁡β+ny=(x_{0}-m)\\sin\\beta+(y_{0}-n)\\cos\\beta+ny=(x0​−m)sinβ+(y0​−n)cosβ+n 因为逆时针旋转β\\betaβ度就相当于顺时针旋转(360−β)(360-\\beta)(360−β)度，在上方公式基础上再作推广到顺时针旋转的情况： x=(x0−m)cos⁡(360−β)−(y0−n)sin⁡(360−β)+m=(x0−m)cos⁡β+(y0−n)sin⁡β+mx=(x_{0}-m)\\cos(360-\\beta)-(y_{0}-n)\\sin(360-\\beta)+m=(x_{0}-m)\\cos\\beta+(y_{0}-n)\\sin\\beta+mx=(x0​−m)cos(360−β)−(y0​−n)sin(360−β)+m=(x0​−m)cosβ+(y0​−n)sinβ+m y=(x0−m)sin⁡(360−β)+(y0−n)cos⁡(360−β)+n=−(x0−m)sin⁡β+(y0−n)cos⁡β+ny=(x_{0}-m)\\sin(360-\\beta)+(y_{0}-n)\\cos(360-\\beta)+n=-(x_{0}-m)\\sin\\beta+(y_{0}-n)\\cos\\beta+ny=(x0​−m)sin(360−β)+(y0​−n)cos(360−β)+n=−(x0​−m)sinβ+(y0​−n)cosβ+n 综上所述，坐标平面内任意一点(x0,y0)(x_{0},y_{0})(x0​,y0​)绕(m,n)(m,n)(m,n)旋转后坐标 {x=(x0−m)cos⁡β∓(y0−n)sin⁡β+my=±(x0−m)sin⁡β+(y0−n)cos⁡β+n\\left\\{ \\begin{aligned} x=(x_{0}-m)\\cos\\beta\\mp (y_{0}-n)\\sin\\beta+m \\\\y=\\pm (x_{0}-m)\\sin\\beta+(y_{0}-n)\\cos\\beta+n \\end{aligned} \\right. {x=(x0​−m)cosβ∓(y0​−n)sinβ+my=±(x0​−m)sinβ+(y0​−n)cosβ+n​ 其中正负/负正号逆时针取上，顺时针取下 ","link":"https://mrchickend.github.io/post/ping-mian-zhi-jiao-zuo-biao-xi-zhong-de-xuan-zhuan-zuo-biao-bian-huan-gong-shi/"},{"title":"直角三角形中三边的幂的关系","content":"对于任意一直角三角形，设三边分别为a,b,ca,b,ca,b,c(其中ccc为斜边)，设nnn为正整数，求an、bn、cna^{n}、b^{n}、c^{n}an、bn、cn之间的关系 ①当n=1n=1n=1时，显然有a+b&gt;ca+b&gt;ca+b&gt;c，对于任何形状的三角形均成立 ②当n=2n=2n=2时，由勾股定理可知，a2+b2=c2a^{2}+b^{2}=c^{2}a2+b2=c2 ③当n≥3n\\ge3n≥3时，有an+bn&lt;cna^{n}+b^{n}&lt;c^{n}an+bn&lt;cn，现对该情况给出两种证明： Proof 1 令a≤b&lt;ca\\le b&lt;ca≤b&lt;c 当n=3n=3n=3时，因为有a×a2≤b×a2a\\times a^{2}\\le b\\times a^{2}a×a2≤b×a2，在不等式两边同时加上b3b^{3}b3: a3+b3≤ba2+b3=b(a2+b2)=bc2&lt;c3a^{3}+b^{3}\\le ba^{2}+b^{3}=b(a^{2}+b^{2})=bc^{2}&lt;c^{3}a3+b3≤ba2+b3=b(a2+b2)=bc2&lt;c3即a3+b3&lt;c3a^{3}+b^{3}&lt;c^{3}a3+b3&lt;c3 假设ak+bk&lt;cka^{k}+b^{k}&lt;c^{k}ak+bk&lt;ck (k&gt;3且k∈N+)(k&gt;3且k\\in \\mathbb{N}^+)(k&gt;3且k∈N+) 当n=k+1n=k+1n=k+1时，类比可得$$a{k+1}+b{k+1}\\le b(a{k}+b{k})&lt;bc{k}&lt;c{k+1}$$即ak+1+bk+1&lt;ck+1a^{k+1}+b^{k+1}&lt;c^{k+1}ak+1+bk+1&lt;ck+1 所以当n≥3n\\ge3n≥3时，an+bn&lt;cna^{n}+b^{n}&lt;c^{n}an+bn&lt;cn Proof 2 设边 aaa 所对锐角为 θ\\thetaθ ，则 a=c×sin⁡θa=c\\times \\sin\\thetaa=c×sinθ ， b=c×cos⁡θb=c\\times \\cos\\thetab=c×cosθ 所以 an=cnsin⁡nθa^{n}=c^{n}\\sin^{n}\\thetaan=cnsinnθ， bn=cncos⁡nθb^{n}=c^{n}\\cos^{n}\\thetabn=cncosnθ， an+bn=cn(sin⁡nθ+cos⁡nθ)a^{n}+b^{n}=c^{n}(\\sin^{n}\\theta+\\cos^{n}\\theta)an+bn=cn(sinnθ+cosnθ) 因为 0&lt;θ&lt;900&lt;\\theta&lt;900&lt;θ&lt;90 ，所以 0&lt;sin⁡θ&lt;10&lt;\\sin\\theta&lt;10&lt;sinθ&lt;1 ， 0&lt;cos⁡θ&lt;10&lt;\\cos\\theta&lt;10&lt;cosθ&lt;1 所以 sin⁡2θ&gt;sin⁡nθ\\sin^{2}\\theta&gt;\\sin^{n}\\thetasin2θ&gt;sinnθ，cos⁡2θ&gt;cos⁡nθ\\cos^{2}\\theta&gt;\\cos^{n}\\thetacos2θ&gt;cosnθ cn(sin⁡nθ+cos⁡nθ)&lt;cn(sin⁡2θ+cos⁡2θ)=cnc^{n}(\\sin^{n}\\theta+\\cos^{n}\\theta)&lt;c^{n}(\\sin^{2}\\theta+\\cos^{2}\\theta)=c^{n}cn(sinnθ+cosnθ)&lt;cn(sin2θ+cos2θ)=cn 即 an+bn&lt;cna^{n}+b^{n}&lt;c^{n}an+bn&lt;cn ","link":"https://mrchickend.github.io/post/zhi-jiao-san-jiao-xing-zhong-san-bian-de-mi-de-guan-xi/"}]}